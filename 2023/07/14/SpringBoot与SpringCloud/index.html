<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>SpringBoot与SpringCloud | 徐子辉的个人站点</title>
  <meta name="author" content="xuzh">
  
  <meta name="description" content="1. SpringBoot
1.1 SpringBoot的作用
SpringBoot是一个快速构建项目并简化项目配置的工具，内部集成了Tomcat及大多数第三方应用和Spring框架的默认配置。与我们学习的SpringMVC和SpringCloud并无冲突,SpringBoot提供的这些默认配置，大大简化了SpringMVC、SpringCloud等基于Spring的Web应用的开发。
1.2.SpringBoot的自动配置原理（如何实现）？
SpringBoot的自动配置是如何实现的？
一般我们的SpringBoot项目启动类都会添加@SpringBootApplication注解，而这个注解的其中一个二级注解是@EnableAutoConfiguration注解。而@EnableAutoConfiguration注解通过@Import注解，以ImportSelector接口的方法来导入classpath下的META-INF/spring.factories文件，这些文件中会指定需要加载的一些类名称。
这些类一般都加了@Configuration注解，并且完成了对某框架（例如Redis、SpringMVC）的默认配置，当这些类符合条件时，就会被实例化，其中的配置生效，那么自动配置自然生效了。">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="SpringBoot与SpringCloud"/>
  <meta property="og:site_name" content="徐子辉的个人站点"/>

  
    <meta property="og:image" content=""/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5d4268fe3f695d6111d5659760d4d452";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

  

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="徐子辉的个人站点" type="application/atom+xml">
</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">徐子辉的个人站点</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class="fa fa-user"></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> SpringBoot与SpringCloud</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  		

	  <h1 id="springboot">1. SpringBoot</h1>
<h2 id="springboot的作用">1.1 SpringBoot的作用</h2>
<p>SpringBoot是一个快速构建项目并简化项目配置的工具，内部集成了Tomcat及大多数第三方应用和Spring框架的默认配置。与我们学习的SpringMVC和SpringCloud并无冲突,SpringBoot提供的这些默认配置，大大简化了SpringMVC、SpringCloud等基于Spring的Web应用的开发。</p>
<h2
id="springboot的自动配置原理如何实现">1.2.SpringBoot的自动配置原理（如何实现）？</h2>
<h3
id="springboot的自动配置是如何实现的">SpringBoot的自动配置是如何实现的？</h3>
<p>一般我们的SpringBoot项目启动类都会添加<code>@SpringBootApplication</code>注解，而这个注解的其中一个二级注解是<code>@EnableAutoConfiguration</code>注解。而<code>@EnableAutoConfiguration</code>注解通过<code>@Import</code>注解，以<code>ImportSelector</code>接口的方法来导入classpath下的<code>META-INF/spring.factories</code>文件，这些文件中会指定需要加载的一些类名称。</p>
<p>这些类一般都加了<code>@Configuration</code>注解，并且完成了对某框架（例如Redis、SpringMVC）的默认配置，当这些类符合条件时，就会被实例化，其中的配置生效，那么自动配置自然生效了。</p>
<span id="more"></span>
<h3 id="满足怎样的条件配置才会生效">满足怎样的条件配置才会生效？</h3>
<p>一般提供默认配置的类都会添加<code>@ConditionalOnXxx</code>这样的注解，例如：<code>@ConditionalOnClass</code>，<code>@ConditionalOnProperties</code>等。<code>@ConditionalOnClass</code>表示只有classpath中存在某些指定的类时，条件满足，此时该配置类才会生效。例如Redis的默认配置其实早就有了，但是只有你引入redis的starter依赖，才满足了条件，触发自动配置。</p>
<h3
id="那如果我需要覆盖这些默认配置呢">那如果我需要覆盖这些默认配置呢？</h3>
<p>有两种方式可以覆盖默认配置：</p>
<ul>
<li>SpringBoot提供默认配置时，会在提供的Bean上加注解@ConditionalOnMissingBean，意思是如果这个Bean不存在时条件满足，那么我们只要配置了相同的Bean，那么SpringBoot提供的默认配置就会失效</li>
<li>SpringBoot提供默认配置时，一些关键属性会通过读取application.yml或者application.properties文件来获取，因此我们可以通过覆盖任意一个文件中的属性来覆盖默认配置。</li>
</ul>
<h2 id="自定义springboot的stater">1.3 自定义SpringBoot的stater？</h2>
<p>项目中某些中间件的客户端（如Redis、ElasticSearch）会进行二次封装，并通过starter方式提供jar包，供大家使用。</p>
<p>一般定义starter包括下面几个子工程：</p>
<ul>
<li>xxx-spring-boot-starter：pom格式，管理当前starter中需要的各种依赖</li>
<li>xxx-spring-boot-autoconfigure：jar格式，自动配置的核心代码</li>
</ul>
<p>以elasticsearch为例来说说autoconfigure中包含哪些</p>
<ul>
<li>elasticsearch的工具类</li>
<li>属性加载的类，一般通过@ConfigurationProperties注解读取yaml文件中的es地址</li>
<li>添加了@Configuration的配置类，作用是初始化elasticsearch工具类，初始化elasticsearch客户端，初始化一些其它必备的实例。</li>
<li>resource下定义META-INF文件夹，并且文件夹下定义spring.factories文件，文件中是key-value形式:key是EnableAutoConfiguration这个注解的全路径名,value是我们自定义自动配置类（加了@Configuration的类），如果有多个以","隔开</li>
</ul>
<h2 id="springboot项目的启动流程">1.4 SpringBoot项目的启动流程</h2>
<p>SpringBoot项目启动第一步就是创建SpringApplication的实例，并且调用SpringApplication.run()这个方法。</p>
<p>创建SpringApplication实例主要完成三件事情：</p>
<ul>
<li>记录当前启动类字节码</li>
<li>判断当前项目类型，普通Servlet、响应式WebFlux、NONE</li>
<li>加载/META-INF/spring.factories文件，初始化ApplicationContextInitializer和ApplicationListener实例</li>
</ul>
<p>而后的run()方法则会创建spring容器，流程如下：</p>
<ul>
<li>准备监听器，监听Spring启动的各个过程</li>
<li>创建并配置环境参数Environment</li>
<li>创建ApplicationContext</li>
<li>prepareContext()：初始化ApplicationContext，准备运行环境</li>
<li>refreshContext(context)：准备Bean工厂，调用一个BeanDefinition和BeanFactory的后处理器，初始化各种Bean，初始化tomcat</li>
<li>afterRefresh()：拓展功能，目前为空</li>
<li>发布容器初始化完毕的事件</li>
</ul>
<h2 id="springboot的配置加载优先级">1.5 SpringBoot的配置加载优先级</h2>
<p>SpringBoot参数配置方式很多，比较常用参数配置方式按照优先级从高到低分别是：</p>
<ul>
<li>在命令行中传入的参数</li>
<li>java 的系统属性，可以通过System.getProperties()获得的内容</li>
<li>操作系统的环境变量</li>
<li>针对不同{profile}环境的配置文件内容，例如
applicaiton-{profile}.yaml</li>
<li>application.yml或application.proerties文件</li>
<li>在@Configration注解修改的类中，通过@PropertySource注解定义的属性</li>
</ul>
<h1 id="springcloud">2 SpringCloud</h1>
<h2 id="springcloud和dubbo的区别">2.1 SpringCloud和Dubbo的区别</h2>
<p>两者都是现在主流的微服务框架，但却存在不少差异：</p>
<ul>
<li>初始定位不同：SpringCloud定位为微服务架构下的一站式解决方案；Dubbo
是 SOA 时代的产物，它的关注点主要在于服务的调用和治理</li>
<li>生态环境不同：SpringCloud依托于Spring平台，具备更加完善的生态体系；而Dubbo一开始只是做RPC远程调用，生态相对匮乏，现在逐渐丰富起来。</li>
<li>调用方式：SpringCloud是采用Http协议做远程调用，接口一般是Rest风格，比较灵活；Dubbo是采用Dubbo协议，接口一般是Java的Service接口，格式固定。但调用时采用Netty的NIO方式，性能较好。</li>
<li>组件差异比较多，例如SpringCloud注册中心一般用Eureka，而Dubbo用的是Zookeeper</li>
</ul>
<p>SpringCloud生态丰富，功能完善，更像是品牌机，Dubbo则相对灵活，可定制性强，更像是组装机。</p>
<p>两者的生态对比：</p>
<table>
<thead>
<tr class="header">
<th>功能</th>
<th>Dubbo</th>
<th>SpringCloud</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>服务注册中心</td>
<td>Zookeeper</td>
<td>Eureka(主流）、Consul、zookeeper</td>
</tr>
<tr class="even">
<td>服务调用方式</td>
<td>RPC基于Dubbo协议</td>
<td>REST API 基于Http协议</td>
</tr>
<tr class="odd">
<td>服务监控</td>
<td>Dubbo-Monitor</td>
<td>Spring Boot Admin</td>
</tr>
<tr class="even">
<td>熔断器</td>
<td>不完善</td>
<td>Spring Cloud Netflix Hystrix</td>
</tr>
<tr class="odd">
<td>服务网关</td>
<td>无</td>
<td>Spring Cloud Netflix Zuul、Gateway</td>
</tr>
<tr class="even">
<td>分布式配置</td>
<td>无</td>
<td>Spring Cloud Config</td>
</tr>
<tr class="odd">
<td>服务跟踪</td>
<td>无</td>
<td>Spring Cloud Sleuth+Zipkin(一般)</td>
</tr>
<tr class="even">
<td>数据流</td>
<td>无</td>
<td>Spring Cloud Stream</td>
</tr>
<tr class="odd">
<td>批量任务</td>
<td>无</td>
<td>Spring Cloud Task</td>
</tr>
<tr class="even">
<td>信息总线</td>
<td>无</td>
<td>Spring Cloud Bus</td>
</tr>
</tbody>
</table>
<p>Spring Cloud 的功能很明显比 Dubbo 更加强大，涵盖面更广，而且作为
Spring 的旗舰项目，它也能够与 Spring Framework、Spring Boot、Spring
Data、Spring Batch 等其他 Spring
项目完美融合，这些对于微服务而言是至关重要的。</p>
<p>使用 Dubbo
构建的微服务架构就像组装电脑，各环节选择自由度很高，但是最终结果很有可能因为一条内存质量不行就点不亮了，总是让人不怎么放心，但是如果使用者是一名高手，那这些都不是问题。</p>
<h2 id="dubbo和feign远程调用的差异">2.2 dubbo和Feign远程调用的差异</h2>
<p>Feign是SpringCloud中的远程调用方式，基于成熟Http协议，所有接口都采用Rest风格。因此接口规范更统一，而且只要符合规范，实现接口的微服务可以采用任意语言或技术开发。但受限于http协议本身的特点，请求和响应格式臃肿，其通信效率相对会差一些。</p>
<p>Dubbo框架默认采用Dubbo自定义通信协议，与Http协议一样底层都是TCP通信。但是Dubbo协议自定义了Java数据序列化和反序列化方式、数据传输格式，因此Dubbo在数据传输性能上会比Http协议要好一些。</p>
<p>不过这种性能差异除非是达极高的并发量级，否则无需过多考虑。</p>
<h2 id="eureka和zookeeper注册中心的区别">2.3
Eureka和Zookeeper注册中心的区别</h2>
<p>SpringCloud和Dubbo都支持多种注册中心，不过目前主流来看SpringCloud用Eureka较多，Dubbo则以Zookeeper为主。两者存在较大的差异：</p>
<ul>
<li>从集群设计来看：Eureka集群各节点平等，没有主从关系，因此可能出现数据不一致情况；ZK为了满足一致性，必须包含主从关系，一主多从。集群无主时，不对外提供服务</li>
<li>CAP原则来看：Eureka满足AP原则，为了保证整个服务可用性，牺牲了集群数据的一致性；而Zookeeper满足CP原则，为了保证各节点数据一致性，牺牲了整个服务的可用性。</li>
<li>服务拉取方式来看：Eureka采用的是服务主动拉取策略，消费者按照固定频率（默认30秒）去Eureka拉取服务并缓存在本地；ZK中的消费者首次启动到ZK订阅自己需要的服务信息，并缓存在本地。然后监听服务列表变化，以后服务变更ZK会推送给消费者。</li>
</ul>
<p><strong>扩展：</strong></p>
<p>首先，Eureka和Zookeeper都是服务治理框架，但是设计上有一定的差别。</p>
<p>先看下CAP原则：C-数据一致性；A-服务可用性；P-服务对网络分区故障的容错性，这三个特性在任何分布式系统中不能同时满足，最多同时满足两个。</p>
<p>Eureka满足AP，Zookeeper满足CP</p>
<p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是Zookeeper和Eureka在一致性与可用性间做出了不同的选择。</p>
<p>Zookeeper：Zookeeper的设计追求数据的一致性，不保证服务的可用性。当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30
~ 120s,
且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<p>Eureka：Eureka追求的是服务的可用性，从而牺牲了数据的一致性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册或时如果发现连接失败，则会自动切换至其它节点，只要有一台Eureka还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况。</p>
<ol type="1">
<li>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</li>
<li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)</li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</li>
</ol>
<p>因此，
Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪。</p>
<p>Eureka集群各节点平等，Zookeeper中有主从之分</p>
<ol type="1">
<li>如果Zookeeper集群中部分宕机，可能会导致整个集群因为选主而阻塞，服务不可用</li>
<li>Eureka集群宕机部分，不会对其它机器产生影响</li>
</ol>
<p>Eureka的服务发现需要主动去拉取，Zookeeper服务发现是监听机制</p>
<ol type="1">
<li>Eureka中获取服务列表后会缓存起来，每隔30秒重新拉取服务列表</li>
<li>Zookeeper则是监听节点信息变化，当服务节点信息变化时，客户端立即就得到通知</li>
</ol>
<h2 id="springcloud中的常用组件有哪些">2.4
SpringCloud中的常用组件有哪些？</h2>
<p>Spring Cloud的子项目很多，比较常见的都是Netflix开源的组件：</p>
<ul>
<li>Spring Cloud Config</li>
</ul>
<p>集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。</p>
<ul>
<li>Spring Cloud Netflix</li>
</ul>
<p>Netflix OSS
开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。</p>
<p>Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；
Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；
Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；
Feign：基于Ribbon和Hystrix的声明式服务调用组件；
Zuul：API网关组件，对请求提供路由及过滤功能。 Spring Cloud Bus
用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。</p>
<ul>
<li>Spring Cloud Consul</li>
</ul>
<p>基于Hashicorp Consul的服务治理组件。</p>
<ul>
<li>Spring Cloud Security</li>
</ul>
<p>安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。</p>
<ul>
<li>Spring Cloud Sleuth</li>
</ul>
<p>Spring
Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。</p>
<ul>
<li>Spring Cloud Stream</li>
</ul>
<p>轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache
Kafka及RabbitMQ。</p>
<ul>
<li>Spring Cloud Task</li>
</ul>
<p>用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。</p>
<ul>
<li>Spring Cloud Zookeeper</li>
</ul>
<p>基于Apache Zookeeper的服务治理组件。</p>
<ul>
<li>Spring Cloud Gateway</li>
</ul>
<p>API网关组件，对请求提供路由及过滤功能。</p>
<ul>
<li>Spring Cloud OpenFeign</li>
</ul>
<p>基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring
MVC注解的接口实现用于服务调用，在Spring Cloud
2.0中已经取代Feign成为了一等公民。</p>
<hr />
<p>未完待续</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2023/08/16/MySQL数据库GROUP_CONCAT()函数输出结果的长度限制/" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2023/06/30/MyBatis配置allowMultiQueries-true允许使用foreach标签批量插入或更新数据/" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	
<section id="comment">
    <script src="https://giscus.app/client.js"
        data-repo="xbronze/giscus"
        data-repo-id="R_kgDOJ4tM7g"
        data-category="Announcements"
        data-category-id="DIC_kwDOJ4tM7s4CXvDw"
        data-mapping="title"
        data-strict="1"
        data-reactions-enabled="1"
        data-emit-metadata="0"
        data-input-position="top"
        data-theme="preferred_color_scheme"
        data-lang="zh-CN"
        data-loading="lazy"
        crossorigin="anonymous"
        async>
    </script>
</section>

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2023-07-14 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/代码人生/">代码人生<span>17</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <a href="/tags/SpringCloud/">SpringCloud<span>2</span></a> <a href="/tags/SpringBoot/">SpringBoot<span>2</span></a>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#springboot"><span class="toc-article-text">1. SpringBoot</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#springboot%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-article-text">1.1 SpringBoot的作用</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0"><span class="toc-article-text">1.2.SpringBoot的自动配置原理（如何实现）？</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-article-text">SpringBoot的自动配置是如何实现的？</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E6%BB%A1%E8%B6%B3%E6%80%8E%E6%A0%B7%E7%9A%84%E6%9D%A1%E4%BB%B6%E9%85%8D%E7%BD%AE%E6%89%8D%E4%BC%9A%E7%94%9F%E6%95%88"><span class="toc-article-text">满足怎样的条件配置才会生效？</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#%E9%82%A3%E5%A6%82%E6%9E%9C%E6%88%91%E9%9C%80%E8%A6%81%E8%A6%86%E7%9B%96%E8%BF%99%E4%BA%9B%E9%BB%98%E8%AE%A4%E9%85%8D%E7%BD%AE%E5%91%A2"><span class="toc-article-text">那如果我需要覆盖这些默认配置呢？</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89springboot%E7%9A%84stater"><span class="toc-article-text">1.3 自定义SpringBoot的stater？</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#springboot%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-article-text">1.4 SpringBoot项目的启动流程</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#springboot%E7%9A%84%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-article-text">1.5 SpringBoot的配置加载优先级</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#springcloud"><span class="toc-article-text">2 SpringCloud</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#springcloud%E5%92%8Cdubbo%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-article-text">2.1 SpringCloud和Dubbo的区别</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#dubbo%E5%92%8Cfeign%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-article-text">2.2 dubbo和Feign远程调用的差异</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#eureka%E5%92%8Czookeeper%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-article-text">2.3
Eureka和Zookeeper注册中心的区别</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#springcloud%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-article-text">2.4
SpringCloud中的常用组件有哪些？</span></a></li></ol></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2025 xuzh
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a>,<a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>,
     <br> Theme by <a target="_blank" rel="noopener" href="https://github.com/blackshow/hexo-theme-freemind.386">Hexo-Theme-Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
